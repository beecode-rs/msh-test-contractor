import { vi } from 'vitest';
import { mockerService } from '#src/mocker/mocker-service';
import { fnUtil } from '#src/util/fn-util';
import { VitestSpyFunctionStrategy } from '#src/vitest-spy/vitest-spy-function-strategy';
export const mocker = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unnecessary-type-parameters
    contract: (contract) => {
        const mockerStrategy = mockerService.strategyFromContract(contract);
        const spy = mockerStrategy.contractSpy();
        const mockRestore = () => {
            mockerStrategy.mockRestore();
        };
        return { mockRestore, spy };
    },
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters
    function: (contract, fnName) => {
        const { module, subjectName, fns } = contract;
        const { terms } = fns[fnName];
        const spy = // eslint-disable-next-line no-ternary
         fnUtil.isConstructor(fnName)
            ? vi.spyOn(module, subjectName)
            : // eslint-disable-next-line no-ternary
                terms[0]?.constructorParams // if function belongs to class mock prototype
                    ? vi.spyOn(module[subjectName].prototype, fnName)
                    : vi.spyOn(module[subjectName], fnName);
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!terms) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`Terms not found in function ${fnName} for module ${subjectName}`);
        }
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        const vitestSpyFunction = new VitestSpyFunctionStrategy({ name: `${subjectName}.${fnName}`, terms });
        spy.mockImplementation(vitestSpyFunction.mockImplementationFactory());
        const mockRestore = () => {
            spy.mockRestore();
        };
        return { mockRestore, spy };
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9ja2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL21vY2tlci9tb2NrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFxQixFQUFFLEVBQUUsTUFBTSxRQUFRLENBQUE7QUFFOUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDRCQUE0QixDQUFBO0FBRTFELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQTtBQUMxQyxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSw4Q0FBOEMsQ0FBQTtBQVF4RixNQUFNLENBQUMsTUFBTSxNQUFNLEdBQUc7SUFDckIsaUhBQWlIO0lBQ2pILFFBQVEsRUFBRSxDQUF1RCxRQUFXLEVBQTZCLEVBQUU7UUFDMUcsTUFBTSxjQUFjLEdBQUcsYUFBYSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBQ25FLE1BQU0sR0FBRyxHQUFHLGNBQWMsQ0FBQyxXQUFXLEVBQUUsQ0FBQTtRQUN4QyxNQUFNLFdBQVcsR0FBRyxHQUFTLEVBQUU7WUFDOUIsY0FBYyxDQUFDLFdBQVcsRUFBRSxDQUFBO1FBQzdCLENBQUMsQ0FBQTtRQUVELE9BQU8sRUFBRSxXQUFXLEVBQUUsR0FBRyxFQUFFLENBQUE7SUFDNUIsQ0FBQztJQUNELDZFQUE2RTtJQUM3RSxRQUFRLEVBQUUsQ0FDVCxRQUFXLEVBQ1gsTUFBWSxFQUNXLEVBQUU7UUFDekIsTUFBTSxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsUUFBUSxDQUFBO1FBQzdDLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFFLENBQUE7UUFFOUIsTUFBTSxHQUFHLEdBQUcsc0NBQXNDO1NBQ2pELE1BQU0sQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDO1lBQzNCLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUM7WUFDL0IsQ0FBQyxDQUFDLHNDQUFzQztnQkFDdkMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLGlCQUFpQixDQUFDLDhDQUE4QztvQkFDMUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUM7b0JBQ2pELENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQTtRQUUxQyx1RUFBdUU7UUFDdkUsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ1osNEVBQTRFO1lBQzVFLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLE1BQU0sZUFBZSxXQUFXLEVBQUUsQ0FBQyxDQUFBO1FBQ25GLENBQUM7UUFFRCw0RUFBNEU7UUFDNUUsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLHlCQUF5QixDQUFDLEVBQUUsSUFBSSxFQUFFLEdBQUcsV0FBVyxJQUFJLE1BQU0sRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUE7UUFDcEcsR0FBRyxDQUFDLGtCQUFrQixDQUFDLGlCQUFpQixDQUFDLHlCQUF5QixFQUFFLENBQUMsQ0FBQTtRQUVyRSxNQUFNLFdBQVcsR0FBRyxHQUFTLEVBQUU7WUFDOUIsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFBO1FBQ2xCLENBQUMsQ0FBQTtRQUVELE9BQU8sRUFBRSxXQUFXLEVBQUUsR0FBRyxFQUFFLENBQUE7SUFDNUIsQ0FBQztDQUNELENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0eXBlIE1vY2tJbnN0YW5jZSwgdmkgfSBmcm9tICd2aXRlc3QnXG5cbmltcG9ydCB7IG1vY2tlclNlcnZpY2UgfSBmcm9tICcjc3JjL21vY2tlci9tb2NrZXItc2VydmljZSdcbmltcG9ydCB7IHR5cGUgQW55Q29udHJhY3QsIHR5cGUgQ29udHJhY3RNb2NrUmV2ZXJ0Rm4sIHR5cGUgUHJvcFR5cGUgfSBmcm9tICcjc3JjL3R5cGVzL2luZGV4J1xuaW1wb3J0IHsgZm5VdGlsIH0gZnJvbSAnI3NyYy91dGlsL2ZuLXV0aWwnXG5pbXBvcnQgeyBWaXRlc3RTcHlGdW5jdGlvblN0cmF0ZWd5IH0gZnJvbSAnI3NyYy92aXRlc3Qtc3B5L3ZpdGVzdC1zcHktZnVuY3Rpb24tc3RyYXRlZ3knXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgdHlwZSBNb2NrZXJDb250cmFjdFJlc3VsdDxTUFkgPSBNb2NrSW5zdGFuY2U8YW55Pj4gPSB7XG5cdHNweTogU1BZXG5cdG1vY2tSZXN0b3JlOiBDb250cmFjdE1vY2tSZXZlcnRGblxufVxuXG5leHBvcnQgY29uc3QgbW9ja2VyID0ge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtcGFyYW1ldGVyc1xuXHRjb250cmFjdDogPFNQWSA9IE1vY2tJbnN0YW5jZTxhbnk+LCBDIGV4dGVuZHMgQW55Q29udHJhY3QgPSBhbnk+KGNvbnRyYWN0OiBDKTogTW9ja2VyQ29udHJhY3RSZXN1bHQ8U1BZPiA9PiB7XG5cdFx0Y29uc3QgbW9ja2VyU3RyYXRlZ3kgPSBtb2NrZXJTZXJ2aWNlLnN0cmF0ZWd5RnJvbUNvbnRyYWN0KGNvbnRyYWN0KVxuXHRcdGNvbnN0IHNweSA9IG1vY2tlclN0cmF0ZWd5LmNvbnRyYWN0U3B5KClcblx0XHRjb25zdCBtb2NrUmVzdG9yZSA9ICgpOiB2b2lkID0+IHtcblx0XHRcdG1vY2tlclN0cmF0ZWd5Lm1vY2tSZXN0b3JlKClcblx0XHR9XG5cblx0XHRyZXR1cm4geyBtb2NrUmVzdG9yZSwgc3B5IH1cblx0fSxcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS10eXBlLXBhcmFtZXRlcnNcblx0ZnVuY3Rpb246IDxDIGV4dGVuZHMgQW55Q29udHJhY3QsIENGTksgZXh0ZW5kcyBFeHRyYWN0PGtleW9mIFByb3BUeXBlPEMsICdmbnMnPiwgc3RyaW5nPj4oXG5cdFx0Y29udHJhY3Q6IEMsXG5cdFx0Zm5OYW1lOiBDRk5LXG5cdCk6IE1vY2tlckNvbnRyYWN0UmVzdWx0ID0+IHtcblx0XHRjb25zdCB7IG1vZHVsZSwgc3ViamVjdE5hbWUsIGZucyB9ID0gY29udHJhY3Rcblx0XHRjb25zdCB7IHRlcm1zIH0gPSBmbnNbZm5OYW1lXSFcblxuXHRcdGNvbnN0IHNweSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10ZXJuYXJ5XG5cdFx0XHRmblV0aWwuaXNDb25zdHJ1Y3Rvcihmbk5hbWUpXG5cdFx0XHRcdD8gdmkuc3B5T24obW9kdWxlLCBzdWJqZWN0TmFtZSlcblx0XHRcdFx0OiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGVybmFyeVxuXHRcdFx0XHRcdHRlcm1zWzBdPy5jb25zdHJ1Y3RvclBhcmFtcyAvLyBpZiBmdW5jdGlvbiBiZWxvbmdzIHRvIGNsYXNzIG1vY2sgcHJvdG90eXBlXG5cdFx0XHRcdFx0PyB2aS5zcHlPbihtb2R1bGVbc3ViamVjdE5hbWVdLnByb3RvdHlwZSwgZm5OYW1lKVxuXHRcdFx0XHRcdDogdmkuc3B5T24obW9kdWxlW3N1YmplY3ROYW1lXSwgZm5OYW1lKVxuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cblx0XHRpZiAoIXRlcm1zKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFRlcm1zIG5vdCBmb3VuZCBpbiBmdW5jdGlvbiAke2ZuTmFtZX0gZm9yIG1vZHVsZSAke3N1YmplY3ROYW1lfWApXG5cdFx0fVxuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuXHRcdGNvbnN0IHZpdGVzdFNweUZ1bmN0aW9uID0gbmV3IFZpdGVzdFNweUZ1bmN0aW9uU3RyYXRlZ3koeyBuYW1lOiBgJHtzdWJqZWN0TmFtZX0uJHtmbk5hbWV9YCwgdGVybXMgfSlcblx0XHRzcHkubW9ja0ltcGxlbWVudGF0aW9uKHZpdGVzdFNweUZ1bmN0aW9uLm1vY2tJbXBsZW1lbnRhdGlvbkZhY3RvcnkoKSlcblxuXHRcdGNvbnN0IG1vY2tSZXN0b3JlID0gKCk6IHZvaWQgPT4ge1xuXHRcdFx0c3B5Lm1vY2tSZXN0b3JlKClcblx0XHR9XG5cblx0XHRyZXR1cm4geyBtb2NrUmVzdG9yZSwgc3B5IH1cblx0fSxcbn1cbiJdfQ==