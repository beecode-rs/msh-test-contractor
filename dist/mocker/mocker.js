import { vi } from 'vitest';
import { JestSpyFunctionStrategy } from '#src/jest-spy/jest-spy-function-strategy';
import { mockerService } from '#src/mocker/mocker-service';
import { fnUtil } from '#src/util/fn-util';
export const mocker = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unnecessary-type-parameters
    contract: (contract) => {
        const mockerStrategy = mockerService.strategyFromContract(contract);
        const spy = mockerStrategy.contractSpy();
        const mockRestore = () => {
            mockerStrategy.mockRestore();
        };
        return { mockRestore, spy };
    },
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters
    function: (contract, fnName) => {
        const { module, subjectName, fns } = contract;
        const { terms } = fns[fnName];
        const spy = // eslint-disable-next-line no-ternary
         fnUtil.isConstructor(fnName)
            ? vi.spyOn(module, subjectName)
            : // eslint-disable-next-line no-ternary
                terms[0]?.constructorParams // if function belongs to class mock prototype
                    ? vi.spyOn(module[subjectName].prototype, fnName)
                    : vi.spyOn(module[subjectName], fnName);
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!terms) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`Terms not found in function ${fnName} for module ${subjectName}`);
        }
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        const jestSpyFunction = new JestSpyFunctionStrategy({ name: `${subjectName}.${fnName}`, terms });
        spy.mockImplementation(jestSpyFunction.mockImplementationFactory());
        const mockRestore = () => {
            spy.mockRestore();
        };
        return { mockRestore, spy };
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9ja2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL21vY2tlci9tb2NrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLFFBQVEsQ0FBQTtBQUUzQixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQTtBQUNsRixPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sNEJBQTRCLENBQUE7QUFFMUQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLG1CQUFtQixDQUFBO0FBUTFDLE1BQU0sQ0FBQyxNQUFNLE1BQU0sR0FBRztJQUNyQixpSEFBaUg7SUFDakgsUUFBUSxFQUFFLENBQW1ELFFBQVcsRUFBNkIsRUFBRTtRQUN0RyxNQUFNLGNBQWMsR0FBRyxhQUFhLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFDLENBQUE7UUFDbkUsTUFBTSxHQUFHLEdBQUcsY0FBYyxDQUFDLFdBQVcsRUFBRSxDQUFBO1FBQ3hDLE1BQU0sV0FBVyxHQUFHLEdBQVMsRUFBRTtZQUM5QixjQUFjLENBQUMsV0FBVyxFQUFFLENBQUE7UUFDN0IsQ0FBQyxDQUFBO1FBRUQsT0FBTyxFQUFFLFdBQVcsRUFBRSxHQUFHLEVBQUUsQ0FBQTtJQUM1QixDQUFDO0lBQ0QsNkVBQTZFO0lBQzdFLFFBQVEsRUFBRSxDQUNULFFBQVcsRUFDWCxNQUFZLEVBQ1csRUFBRTtRQUN6QixNQUFNLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxHQUFHLEVBQUUsR0FBRyxRQUFRLENBQUE7UUFDN0MsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUUsQ0FBQTtRQUU5QixNQUFNLEdBQUcsR0FBRyxzQ0FBc0M7U0FDakQsTUFBTSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUM7WUFDM0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQztZQUMvQixDQUFDLENBQUMsc0NBQXNDO2dCQUN2QyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsaUJBQWlCLENBQUMsOENBQThDO29CQUMxRSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQztvQkFDakQsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFBO1FBRTFDLHVFQUF1RTtRQUN2RSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDWiw0RUFBNEU7WUFDNUUsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsTUFBTSxlQUFlLFdBQVcsRUFBRSxDQUFDLENBQUE7UUFDbkYsQ0FBQztRQUVELDRFQUE0RTtRQUM1RSxNQUFNLGVBQWUsR0FBRyxJQUFJLHVCQUF1QixDQUFDLEVBQUUsSUFBSSxFQUFFLEdBQUcsV0FBVyxJQUFJLE1BQU0sRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUE7UUFDaEcsR0FBRyxDQUFDLGtCQUFrQixDQUFDLGVBQWUsQ0FBQyx5QkFBeUIsRUFBRSxDQUFDLENBQUE7UUFFbkUsTUFBTSxXQUFXLEdBQUcsR0FBUyxFQUFFO1lBQzlCLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQTtRQUNsQixDQUFDLENBQUE7UUFFRCxPQUFPLEVBQUUsV0FBVyxFQUFFLEdBQUcsRUFBRSxDQUFBO0lBQzVCLENBQUM7Q0FDRCxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmkgfSBmcm9tICd2aXRlc3QnXG5cbmltcG9ydCB7IEplc3RTcHlGdW5jdGlvblN0cmF0ZWd5IH0gZnJvbSAnI3NyYy9qZXN0LXNweS9qZXN0LXNweS1mdW5jdGlvbi1zdHJhdGVneSdcbmltcG9ydCB7IG1vY2tlclNlcnZpY2UgfSBmcm9tICcjc3JjL21vY2tlci9tb2NrZXItc2VydmljZSdcbmltcG9ydCB7IHR5cGUgQW55Q29udHJhY3QsIHR5cGUgQ29udHJhY3RNb2NrUmV2ZXJ0Rm4sIHR5cGUgUHJvcFR5cGUgfSBmcm9tICcjc3JjL3R5cGVzL2luZGV4J1xuaW1wb3J0IHsgZm5VdGlsIH0gZnJvbSAnI3NyYy91dGlsL2ZuLXV0aWwnXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgdHlwZSBNb2NrZXJDb250cmFjdFJlc3VsdDxTUFkgPSB2aS5TcGllZDxhbnk+PiA9IHtcblx0c3B5OiBTUFlcblx0bW9ja1Jlc3RvcmU6IENvbnRyYWN0TW9ja1JldmVydEZuXG59XG5cbmV4cG9ydCBjb25zdCBtb2NrZXIgPSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1wYXJhbWV0ZXJzXG5cdGNvbnRyYWN0OiA8U1BZID0gdmkuU3BpZWQ8YW55PiwgQyBleHRlbmRzIEFueUNvbnRyYWN0ID0gYW55Pihjb250cmFjdDogQyk6IE1vY2tlckNvbnRyYWN0UmVzdWx0PFNQWT4gPT4ge1xuXHRcdGNvbnN0IG1vY2tlclN0cmF0ZWd5ID0gbW9ja2VyU2VydmljZS5zdHJhdGVneUZyb21Db250cmFjdChjb250cmFjdClcblx0XHRjb25zdCBzcHkgPSBtb2NrZXJTdHJhdGVneS5jb250cmFjdFNweSgpXG5cdFx0Y29uc3QgbW9ja1Jlc3RvcmUgPSAoKTogdm9pZCA9PiB7XG5cdFx0XHRtb2NrZXJTdHJhdGVneS5tb2NrUmVzdG9yZSgpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgbW9ja1Jlc3RvcmUsIHNweSB9XG5cdH0sXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1wYXJhbWV0ZXJzXG5cdGZ1bmN0aW9uOiA8QyBleHRlbmRzIEFueUNvbnRyYWN0LCBDRk5LIGV4dGVuZHMgRXh0cmFjdDxrZXlvZiBQcm9wVHlwZTxDLCAnZm5zJz4sIHN0cmluZz4+KFxuXHRcdGNvbnRyYWN0OiBDLFxuXHRcdGZuTmFtZTogQ0ZOS1xuXHQpOiBNb2NrZXJDb250cmFjdFJlc3VsdCA9PiB7XG5cdFx0Y29uc3QgeyBtb2R1bGUsIHN1YmplY3ROYW1lLCBmbnMgfSA9IGNvbnRyYWN0XG5cdFx0Y29uc3QgeyB0ZXJtcyB9ID0gZm5zW2ZuTmFtZV0hXG5cblx0XHRjb25zdCBzcHkgPSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGVybmFyeVxuXHRcdFx0Zm5VdGlsLmlzQ29uc3RydWN0b3IoZm5OYW1lKVxuXHRcdFx0XHQ/IHZpLnNweU9uKG1vZHVsZSwgc3ViamVjdE5hbWUpXG5cdFx0XHRcdDogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRlcm5hcnlcblx0XHRcdFx0XHR0ZXJtc1swXT8uY29uc3RydWN0b3JQYXJhbXMgLy8gaWYgZnVuY3Rpb24gYmVsb25ncyB0byBjbGFzcyBtb2NrIHByb3RvdHlwZVxuXHRcdFx0XHRcdD8gdmkuc3B5T24obW9kdWxlW3N1YmplY3ROYW1lXS5wcm90b3R5cGUsIGZuTmFtZSlcblx0XHRcdFx0XHQ6IHZpLnNweU9uKG1vZHVsZVtzdWJqZWN0TmFtZV0sIGZuTmFtZSlcblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG5cdFx0aWYgKCF0ZXJtcykge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBUZXJtcyBub3QgZm91bmQgaW4gZnVuY3Rpb24gJHtmbk5hbWV9IGZvciBtb2R1bGUgJHtzdWJqZWN0TmFtZX1gKVxuXHRcdH1cblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcblx0XHRjb25zdCBqZXN0U3B5RnVuY3Rpb24gPSBuZXcgSmVzdFNweUZ1bmN0aW9uU3RyYXRlZ3koeyBuYW1lOiBgJHtzdWJqZWN0TmFtZX0uJHtmbk5hbWV9YCwgdGVybXMgfSlcblx0XHRzcHkubW9ja0ltcGxlbWVudGF0aW9uKGplc3RTcHlGdW5jdGlvbi5tb2NrSW1wbGVtZW50YXRpb25GYWN0b3J5KCkpXG5cblx0XHRjb25zdCBtb2NrUmVzdG9yZSA9ICgpOiB2b2lkID0+IHtcblx0XHRcdHNweS5tb2NrUmVzdG9yZSgpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgbW9ja1Jlc3RvcmUsIHNweSB9XG5cdH0sXG59XG4iXX0=