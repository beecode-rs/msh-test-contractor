import { vi } from 'vitest';
import { VitestSpyFunctionStrategy } from '#src/vitest-spy/vitest-spy-function-strategy';
import { mockerService } from '#src/mocker/mocker-service';
import { fnUtil } from '#src/util/fn-util';
export const mocker = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unnecessary-type-parameters
    contract: (contract) => {
        const mockerStrategy = mockerService.strategyFromContract(contract);
        const spy = mockerStrategy.contractSpy();
        const mockRestore = () => {
            mockerStrategy.mockRestore();
        };
        return { mockRestore, spy };
    },
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters
    function: (contract, fnName) => {
        const { module, subjectName, fns } = contract;
        const { terms } = fns[fnName];
        const spy = // eslint-disable-next-line no-ternary
         fnUtil.isConstructor(fnName)
            ? vi.spyOn(module, subjectName)
            : // eslint-disable-next-line no-ternary
                terms[0]?.constructorParams // if function belongs to class mock prototype
                    ? vi.spyOn(module[subjectName].prototype, fnName)
                    : vi.spyOn(module[subjectName], fnName);
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!terms) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`Terms not found in function ${fnName} for module ${subjectName}`);
        }
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        const vitestSpyFunction = new VitestSpyFunctionStrategy({ name: `${subjectName}.${fnName}`, terms });
        spy.mockImplementation(vitestSpyFunction.mockImplementationFactory());
        const mockRestore = () => {
            spy.mockRestore();
        };
        return { mockRestore, spy };
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9ja2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL21vY2tlci9tb2NrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLFFBQVEsQ0FBQTtBQUUzQixPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSw4Q0FBOEMsQ0FBQTtBQUN4RixPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sNEJBQTRCLENBQUE7QUFFMUQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLG1CQUFtQixDQUFBO0FBUTFDLE1BQU0sQ0FBQyxNQUFNLE1BQU0sR0FBRztJQUNyQixpSEFBaUg7SUFDakgsUUFBUSxFQUFFLENBQW1ELFFBQVcsRUFBNkIsRUFBRTtRQUN0RyxNQUFNLGNBQWMsR0FBRyxhQUFhLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFDLENBQUE7UUFDbkUsTUFBTSxHQUFHLEdBQUcsY0FBYyxDQUFDLFdBQVcsRUFBRSxDQUFBO1FBQ3hDLE1BQU0sV0FBVyxHQUFHLEdBQVMsRUFBRTtZQUM5QixjQUFjLENBQUMsV0FBVyxFQUFFLENBQUE7UUFDN0IsQ0FBQyxDQUFBO1FBRUQsT0FBTyxFQUFFLFdBQVcsRUFBRSxHQUFHLEVBQUUsQ0FBQTtJQUM1QixDQUFDO0lBQ0QsNkVBQTZFO0lBQzdFLFFBQVEsRUFBRSxDQUNULFFBQVcsRUFDWCxNQUFZLEVBQ1csRUFBRTtRQUN6QixNQUFNLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxHQUFHLEVBQUUsR0FBRyxRQUFRLENBQUE7UUFDN0MsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUUsQ0FBQTtRQUU5QixNQUFNLEdBQUcsR0FBRyxzQ0FBc0M7U0FDakQsTUFBTSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUM7WUFDM0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQztZQUMvQixDQUFDLENBQUMsc0NBQXNDO2dCQUN2QyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsaUJBQWlCLENBQUMsOENBQThDO29CQUMxRSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQztvQkFDakQsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFBO1FBRTFDLHVFQUF1RTtRQUN2RSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDWiw0RUFBNEU7WUFDNUUsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsTUFBTSxlQUFlLFdBQVcsRUFBRSxDQUFDLENBQUE7UUFDbkYsQ0FBQztRQUVELDRFQUE0RTtRQUM1RSxNQUFNLGlCQUFpQixHQUFHLElBQUkseUJBQXlCLENBQUMsRUFBRSxJQUFJLEVBQUUsR0FBRyxXQUFXLElBQUksTUFBTSxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQTtRQUNwRyxHQUFHLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLENBQUMseUJBQXlCLEVBQUUsQ0FBQyxDQUFBO1FBRXJFLE1BQU0sV0FBVyxHQUFHLEdBQVMsRUFBRTtZQUM5QixHQUFHLENBQUMsV0FBVyxFQUFFLENBQUE7UUFDbEIsQ0FBQyxDQUFBO1FBRUQsT0FBTyxFQUFFLFdBQVcsRUFBRSxHQUFHLEVBQUUsQ0FBQTtJQUM1QixDQUFDO0NBQ0QsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZpIH0gZnJvbSAndml0ZXN0J1xuXG5pbXBvcnQgeyBWaXRlc3RTcHlGdW5jdGlvblN0cmF0ZWd5IH0gZnJvbSAnI3NyYy92aXRlc3Qtc3B5L3ZpdGVzdC1zcHktZnVuY3Rpb24tc3RyYXRlZ3knXG5pbXBvcnQgeyBtb2NrZXJTZXJ2aWNlIH0gZnJvbSAnI3NyYy9tb2NrZXIvbW9ja2VyLXNlcnZpY2UnXG5pbXBvcnQgeyB0eXBlIEFueUNvbnRyYWN0LCB0eXBlIENvbnRyYWN0TW9ja1JldmVydEZuLCB0eXBlIFByb3BUeXBlIH0gZnJvbSAnI3NyYy90eXBlcy9pbmRleCdcbmltcG9ydCB7IGZuVXRpbCB9IGZyb20gJyNzcmMvdXRpbC9mbi11dGlsJ1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IHR5cGUgTW9ja2VyQ29udHJhY3RSZXN1bHQ8U1BZID0gdmkuU3BpZWQ8YW55Pj4gPSB7XG5cdHNweTogU1BZXG5cdG1vY2tSZXN0b3JlOiBDb250cmFjdE1vY2tSZXZlcnRGblxufVxuXG5leHBvcnQgY29uc3QgbW9ja2VyID0ge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtcGFyYW1ldGVyc1xuXHRjb250cmFjdDogPFNQWSA9IHZpLlNwaWVkPGFueT4sIEMgZXh0ZW5kcyBBbnlDb250cmFjdCA9IGFueT4oY29udHJhY3Q6IEMpOiBNb2NrZXJDb250cmFjdFJlc3VsdDxTUFk+ID0+IHtcblx0XHRjb25zdCBtb2NrZXJTdHJhdGVneSA9IG1vY2tlclNlcnZpY2Uuc3RyYXRlZ3lGcm9tQ29udHJhY3QoY29udHJhY3QpXG5cdFx0Y29uc3Qgc3B5ID0gbW9ja2VyU3RyYXRlZ3kuY29udHJhY3RTcHkoKVxuXHRcdGNvbnN0IG1vY2tSZXN0b3JlID0gKCk6IHZvaWQgPT4ge1xuXHRcdFx0bW9ja2VyU3RyYXRlZ3kubW9ja1Jlc3RvcmUoKVxuXHRcdH1cblxuXHRcdHJldHVybiB7IG1vY2tSZXN0b3JlLCBzcHkgfVxuXHR9LFxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtcGFyYW1ldGVyc1xuXHRmdW5jdGlvbjogPEMgZXh0ZW5kcyBBbnlDb250cmFjdCwgQ0ZOSyBleHRlbmRzIEV4dHJhY3Q8a2V5b2YgUHJvcFR5cGU8QywgJ2Zucyc+LCBzdHJpbmc+Pihcblx0XHRjb250cmFjdDogQyxcblx0XHRmbk5hbWU6IENGTktcblx0KTogTW9ja2VyQ29udHJhY3RSZXN1bHQgPT4ge1xuXHRcdGNvbnN0IHsgbW9kdWxlLCBzdWJqZWN0TmFtZSwgZm5zIH0gPSBjb250cmFjdFxuXHRcdGNvbnN0IHsgdGVybXMgfSA9IGZuc1tmbk5hbWVdIVxuXG5cdFx0Y29uc3Qgc3B5ID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRlcm5hcnlcblx0XHRcdGZuVXRpbC5pc0NvbnN0cnVjdG9yKGZuTmFtZSlcblx0XHRcdFx0PyB2aS5zcHlPbihtb2R1bGUsIHN1YmplY3ROYW1lKVxuXHRcdFx0XHQ6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10ZXJuYXJ5XG5cdFx0XHRcdFx0dGVybXNbMF0/LmNvbnN0cnVjdG9yUGFyYW1zIC8vIGlmIGZ1bmN0aW9uIGJlbG9uZ3MgdG8gY2xhc3MgbW9jayBwcm90b3R5cGVcblx0XHRcdFx0XHQ/IHZpLnNweU9uKG1vZHVsZVtzdWJqZWN0TmFtZV0ucHJvdG90eXBlLCBmbk5hbWUpXG5cdFx0XHRcdFx0OiB2aS5zcHlPbihtb2R1bGVbc3ViamVjdE5hbWVdLCBmbk5hbWUpXG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuXHRcdGlmICghdGVybXMpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcblx0XHRcdHRocm93IG5ldyBFcnJvcihgVGVybXMgbm90IGZvdW5kIGluIGZ1bmN0aW9uICR7Zm5OYW1lfSBmb3IgbW9kdWxlICR7c3ViamVjdE5hbWV9YClcblx0XHR9XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG5cdFx0Y29uc3Qgdml0ZXN0U3B5RnVuY3Rpb24gPSBuZXcgVml0ZXN0U3B5RnVuY3Rpb25TdHJhdGVneSh7IG5hbWU6IGAke3N1YmplY3ROYW1lfS4ke2ZuTmFtZX1gLCB0ZXJtcyB9KVxuXHRcdHNweS5tb2NrSW1wbGVtZW50YXRpb24odml0ZXN0U3B5RnVuY3Rpb24ubW9ja0ltcGxlbWVudGF0aW9uRmFjdG9yeSgpKVxuXG5cdFx0Y29uc3QgbW9ja1Jlc3RvcmUgPSAoKTogdm9pZCA9PiB7XG5cdFx0XHRzcHkubW9ja1Jlc3RvcmUoKVxuXHRcdH1cblxuXHRcdHJldHVybiB7IG1vY2tSZXN0b3JlLCBzcHkgfVxuXHR9LFxufVxuIl19